% Copyright © 2015 Fabian Köhler <fkoehler1024@googlemail.com>
\usetikzlibrary{math}
\usetikzlibrary{arrows.meta}

%%%%%%%%%%%%%%%%%
% Configuration %
%%%%%%%%%%%%%%%%%

% config variables
\tikzmath{
  % number of processors in the diagram (not used in manual block drawing)
  \numProc = 4;
  %
  % width of sweep blocks
  \blockWidth = 1.8;
  %
  % horizontal space between blocks
  \blockHSpace = 0.9;
  %
  % vertical space between blocks
  \blockVSpace = 0.05;
  %
  % height of coarse sweep blocks
  \coarseHeight = 0.3;
  %
  % height of fine sweep blocks
  \fineHeight = 1.3;
  \axisHSpace = 1.001*\blockHSpace;
  \axisVSpace = 0.15;
  \ticksHeight = 0.1;
  \ticksOffset = 0.4;
  \drawComm = 1;
}

% draw functions for elements (blocks, lines, ...)
\tikzmath{
  % specify how coarse sweep blocks will be drawn
  function drawCoarseSweep(\xa, \ya, \xb, \yb) {
      { \fill[red] (\xa, \ya) rectangle (\xb, \yb); };
  };
  % specify how fine sweep blocks will be drawn
  function drawFineSweep(\xa, \ya, \xb, \yb) {
      { \fill[blue] (\xa, \ya) rectangle (\xb, \yb); };
  };
  function drawAxis(\xa, \ya, \xb, \yb) {
      { \draw[->,>=latex,thick] (\xa, \ya) -- (\xb, \yb); };
  };
  function drawProcTick(\x, \proc) {
      { \draw (\x, -\axisVSpace) -- (\x, -\axisVSpace-\ticksHeight); };
      { \node at (\x,-\ticksHeight-\ticksOffset) {$P_{\pgfmathprintnumber{\proc}}$}; };
  };
  function drawTimeTick(\x, \i) {
      { \draw (\x, -\axisVSpace) -- (\x, -\axisVSpace-\ticksHeight); };
      { \node at (\x,-\ticksHeight-\ticksOffset) {$t_{\pgfmathprintnumber{\i}}$}; };
  };
  function drawCoarseComm(\xa, \ya, \xb, \yb) {
      \xh = (0.59*\xb+0.41*\xa);
      \yh = (0.59*\yb+0.41*\ya);
      { \draw[-{Triangle[open]}] (\xa,\ya) -- (\xh,\yh); };
      { \draw (\xh,\yh) -- (\xb,\yb); };
  };
  function drawFineComm(\xa, \ya, \xb, \yb) {
      \xh = (0.59*\xb+0.41*\xa);
      \yh = (0.59*\yb+0.41*\ya);
      { \draw[-{Triangle[open]},>=latex,black!60!green] (\xa,\ya) -- (\xh,\yh); };
      { \draw[black!60!green] (\xh,\yh) -- (\xb,\yb); };
  };
  function labelYAxis(\pfasstSteps) {
      \y = getPfasstHeight(-\ticksOffset, \pfasstSteps)/2;
      { \node[rotate=90] at (-\axisHSpace-\ticksOffset, \y) { computation time }; };
  };
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Functions to calculate positions %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tikzmath{
  % get the x coordinate where a process starts
  function procX1(\proc) {
      if \proc == 0 then {
        return \proc*\blockWidth;
      } else {
        return \proc*\blockWidth+\proc*\blockHSpace;
      };
  };
  %
  % get the x coordinate where a process ends
  function procX2(\proc) {
      if \proc == 0 then {
          return (\proc+1)*\blockWidth;
      } else {
          return (\proc+1)*\blockWidth+\proc*\blockHSpace;
      };
  };
  %
  % get the y coordinate where to start a block
  % the number of coarse and fine blocks in the stack has to be specified
  function blockY(\nCoarse, \nFine) {
      return \nCoarse*\coarseHeight+\nFine*\fineHeight+(\nCoarse+\nFine)*\blockVSpace;
  };
  %
  % number of coarse sweeps in prediction on a processor
  function numPredictBlocks(\proc) {
      return \proc+1;
  };
  %
  % number of coarse sweeps in prediction up to a certain step on a processor
  function numPredictBlocksStep(\proc, \step) {
      if \step >= \proc then {
        return \proc+1;
      } else {
        return \step+1;
      };
  };
  function getPfasstWidth(\unused) {
    return (\numProc-1)*(\blockWidth+\blockHSpace)+\blockWidth;
  };
  function getPfasstHeight(\pfasstSteps) {
      \predictHeight = (\numProc-1)*(\coarseHeight+\blockVSpace)+\coarseHeight;
      if \pfasstSteps == 0 then {
          return \predictHeight;
      };
      \h = (\pfasstSteps-1)*(\coarseHeight+\fineHeight+2*\blockVSpace)+\coarseHeight+\fineHeight+\blockVSpace;
      return \h+\predictHeight;
  };
  function getProcTickX(\proc) {
      if \proc == 0 then {
          return \blockWidth/2;
      } else {
          return \proc*(\blockWidth+\blockHSpace)+\blockWidth/2;
      };
  };
  function getTimeTickX(\i) {
      if \i == 0 then {
          return -\blockHSpace/2;
      } else {
          return (\i-1)*(\blockWidth+\blockHSpace)+\blockWidth+\blockHSpace/2;
      };
  };
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Functions to draw individual sweep blocks %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tikzmath{
  % draw a coarse sweep block on stack of a certain processor that contains
  % a given number of coarse and fine blocks
  function coarseSweep(\proc, \nCoarse, \nFine) {
      \xa = procX1(\proc);
      \xb = procX2(\proc);
      \ya = blockY(\nCoarse, \nFine);
      \yb = \ya+\coarseHeight;
      drawCoarseSweep(\xa, \ya, \xb, \yb);
      if \drawComm == 1 then {
          if \proc > 0 then {
              if \nCoarse > 0 then {
                  \xa = procX2(\proc-1);
                  \ya = blockY(\nCoarse-1, \nFine)+\coarseHeight;
                  \xb = procX1(\proc);
                  \yb = blockY(\nCoarse, \nFine);
                  drawCoarseComm(\xa,\ya,\xb,\yb);
              };
          };
      };
  };
  %
  % draw a fine sweep block on stack of a certain processor that contains
  % a given number of coarse and fine blocks
  function fineSweep(\proc, \nCoarse, \nFine) {
      \xa = procX1(\proc);
      \xb = procX2(\proc);
      \ya = blockY(\nCoarse, \nFine);
      \yb = \ya+\fineHeight;
      drawFineSweep(\xa, \ya, \xb, \yb);
      if \drawComm == 1 then {
          if \proc > 0 then {
              if \nFine > 0 then {
                  \xa = procX2(\proc-1);
                  \ya = blockY(\nCoarse-2, \nFine-1);
                  \xb = procX1(\proc);
                  \yb = blockY(\nCoarse, \nFine);
                  drawFineComm(\xa, \ya, \xb, \yb);
              };
          };
      };
  };
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Functions to draw bigger parts of pfasst at once %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tikzmath{
  % draw a single step of the prediction on all processors
  function predictStep(\step) {
    for \proc in {0, ..., \numProc-1}{
      \n = numPredictBlocksStep(\proc, \step);
      coarseSweep(\proc, \n-1, 0);
    };
  };
  %
  % draw fine sweeps of pfasst step
  function pfasstStepFine(\step) {
    for \proc in {0, ..., \numProc-1}{
      \nCoarse = \step+numPredictBlocks(\proc);
      \nFine   = \step;
      fineSweep(\proc, \nCoarse, \nFine);
    };
  };
  %
  % draw coarse sweeps of pfasst step
  function pfasstStepCoarse(\step) {
    for \proc in {0, ..., \numProc-1}{
      \nCoarse = \step+numPredictBlocks(\proc);
      \nFine   = \step+1;
      coarseSweep(\proc, \nCoarse, \nFine);
    };
  };
  %
  % draw the full prediction on all processors
  % the parameter is not used, but it seems that you cannot use functions
  % without parameters
  function predict(\unused) {
    for \step in {0, ..., \numProc-1}{
      predictStep(\step);
    };
  };
  %
  % draw a full pfasst step
  function pfasstStep(\step) {
    for \proc in {0, ..., \numProc-1}{
      pfasstStepFine(\step);
      pfasstStepCoarse(\step);
    };
  };
  %
  % draw the full algorithm with a specified number of pfasst steps
  function pfasst(\steps) {
    predict(0);
    for \step in {0, ..., \steps-1}{
      pfasstStep(\step);
    };
  };
}



%%%%%%%%%%%%%%%%%%%%%%%%%%
% Functions to draw axes %
%%%%%%%%%%%%%%%%%%%%%%%%%%
\tikzmath{
  function drawXAxis(\unused) {
    \w = getPfasstWidth(0)+\axisHSpace;
    drawAxis(-\axisHSpace, -\axisVSpace, \w, -\axisVSpace);
    for \proc in {0, ..., \numProc-1}{
        \x = getProcTickX(\proc);
        drawProcTick(\x, \proc);
        \x = getTimeTickX(\proc);
        drawTimeTick(\x, \proc);
    };
    \x = getTimeTickX(\numProc);
    drawTimeTick(\x, \numProc);
  };
  function drawYAxis(\pfasstSteps) {
    \h = getPfasstHeight(\pfasstSteps)+\axisVSpace;
    drawAxis(-\axisHSpace, -\axisVSpace, -\axisHSpace, \h);
    labelYAxis(\pfasstSteps);
  };
  function drawAxes(\pfasstSteps) {
    drawXAxis(0);
    drawYAxis(\pfasstSteps);
  };
}
